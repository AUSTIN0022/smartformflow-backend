import logger from "../config/logger";
import { redis } from "../config/redis";
import { PublicFormResponseDTO } from "../dtos/submissions/publicForm-response.dto";
import { AdminSubmissionListResponseDTO, AdminSubmissionResponseDTO, SubmissionResponseDTO } from "../dtos/submissions/submission-response.dto";
import { NotFoundError } from "../errors/http-errors";
import { toPublicFormResponseDTO } from "../mappers/publicForm.mapper";
import { IEventRepository } from "../repositories/event.repo";
import { IFormRepository } from "../repositories/form.repo";
import { ISubmissionRepository } from "../repositories/submission.repo";
import { StartSubmissionInput, SubmissionFilterInput, SubmissionFormInput } from "../validators/submission.schema";
import { VisitorInput } from "../validators/visitor.schema";


export class SubmissionService {
  constructor(
    private submissionRepo: ISubmissionRepository,
    private formRepo: IFormRepository,
    private eventRepo: IEventRepository,
    // private redis?: RedisClient // injected later
  ) {}

  /** Public: GET /api/forms/:slug 
   * 1. Validate event exists & isActive
   * 2. Validate form exists & isPublisted
   * 3. Map form -> PublicFormResponseDTO 
  */
  async getPublicForm(slug: string): Promise<PublicFormResponseDTO> {
    const cacheKey = `public:form:${slug}`
    const cached = await redis.get(cacheKey);
    if(cached) {
        return JSON.parse(cached);
    }

    // Cache miss - fetch from database
    const event = await this.eventRepo.findBySlug(slug);
    if (!event || event.status !== "ACTIVE" ) {
      throw new NotFoundError("Event not found or inactive");
    }
    
    const form = await this.formRepo.findByEventId(event.id);
    if(!form || !form.publishedAt ) {
      throw new NotFoundError("Form not found or not published");
    }

    const dto = toPublicFormResponseDTO({event, form});

    // cache for future
    await redis.set(cacheKey, JSON.stringify(dto),"EX", 60 * 60 );

    return dto
    
  };

  /** Public: POST /api/forms/:slug/visit 
   * 1. Upsert Visitor
   * 2. create VISITED session
   * 
   * Redis:
   * - INCR event:{eventId}:visits
  */
  async recordVisit(input: VisitorInput): Promise<void> {
    const { slug, visitor } = input
    
    const event = await this.eventRepo.findBySlug(slug);
    if(!event || event.status !== "ACTIVE") {
        throw new NotFoundError("Event not found or inactive");   
    }
    
    const dbVisitor = await this.submissionRepo.upsertVisitor(visitor);
    
     /** 
      * Future enchancement
     * Add Redis first logic here if scale is more then 50K visit/day
    */
    await this.submissionRepo.createVisitSession({
        visitorId: dbVisitor.id,
        eventId: event.id,
        status: "VISITED",
    });
    
    try {
        const visitKey = `analytics:event:${event.id}:visitor:${dbVisitor.id}`;
        const isNewVisit = await redis.set(visitKey, "1",  "EX", 24 * 60 * 60, "NX");

        if (isNewVisit === "OK") { 
            await redis.incr(`analytics:event:${event.id}:visits`);
        }
    }  catch(err) {
        logger.warn("Redis analytics failed", err);
    }
  };

  /** Public: POST /api/forms/:slug/start 
   * 1. Ensure VISITED session exits
   * 2. Update session -> STARTED
   * 
   * Redis:
   * = INCR event:{eventId}:started
  */
  async startSubmission(input: StartSubmissionInput): Promise<void> {
    const { slug, visitor } = input;
    
    const event = await this.eventRepo.findBySlug(slug);
    if(!event || event.status !== "ACTIVE") {
        throw new NotFoundError("Event not found or inactive");
    }
    
    const form = await this.formRepo.findByEventId(event.id);
    if(!form || !form.publishedAt) {
        throw new NotFoundError("Form not available");
    }

    const dbVisitor = await this.submissionRepo.upsertVisitor({ uuid: visitor.uuid });

    await this.submissionRepo.createVisitSession({
        visitorId: dbVisitor.id,
        eventId: event.id,
        status: "STARTED",
    });

    try {
        const startKey = `analytics:event:${event.id}:visitor:${dbVisitor.id}:started`;
        const isNew = await redis.set(startKey, "1","EX", 86400, "NX");

        if(isNew === "OK") {
            await redis.incr(`analytics:event:${event.id}:started`);
        }
        
    } catch(err) {
        logger.warn("Redis analytics failed", err);
    }
  };

  /** Public: POST /api/forms/:slug/submit 
   * 
   * Atomic Flow:
   * 1. Validate event & publised form
   * 2. Validate answers against form fields
   * 3. Upsert visitor
   * 4. Deduplicate or create Contact
   * 5. create submission + answers (transaction)
   * 6. update visitsesssion -> submitted
   * 
   * Redis: - INCR event:{eventId}:submitted 
  */
  async submitForm(input: SubmissionFormInput): Promise<SubmissionResponseDTO> {
    
    const { slug, visitor, contact, answers } = input;
    // - Resolve event + form
    const event = await this.eventRepo.findBySlug(slug);
    if(!event || event.status !== "ACTIVE" ){
        throw new NotFoundError("Event not found or inactive");
    }
    const form = await this.formRepo.findByEventId(event.id);
    if(!form || !form.publishedAt) {
        throw new NotFoundError("Form not available");
    }
    // TODO: Validate answers vs form schema
    
    // - Upsert visitor
    const dbVisitor = await this.submissionRepo.upsertVisitor(visitor);
    // - Handle contact
    let contactId: string | undefined;
    
    if (contact?.email || contact?.phone) {
        const existing = await this.submissionRepo.findContactByEmailOrPhone(contact.email, contact.phone);
        if(existing) {
            contactId = existing.id;
        } else {
            const created = await this.submissionRepo.createContact({
                ...(contact.name && { name: contact.name }),
                ...(contact.email && { email: contact.email }),
                ...(contact.phone && { phone: contact.phone })
            } );
            contactId = created.id;
        }
    }
    // - Create full submission
    const submission = await this.submissionRepo.createFullSubmission({
        formId: form.id,
        eventId: event.id,
        visitorId: dbVisitor.id,
        ...(contactId ? { contactId }: { }),
        status: "SUBMITTED",
        answers: answers.map((a) => ({
            fieldId: a.fieldId,
            fieldKey: a.fieldKey,
            ...(a.valueText !== undefined && { valueText: a.valueText }),
            ...(a.valueNumber !== undefined && { valueNumber: a.valueNumber }),
            ...(a.valueBoolean !== undefined && { valueBoolean: a.valueBoolean }),
            ...(a.valueDate && { valueDate: new Date(a.valueDate) }),
            ...(a.valueJson !== undefined && { valueJson: a.valueJson }),
            ...(a.fileUrl !== undefined && { fileUrl: a.fileUrl }),
        }))

    })
    // - Redis increment
    try {
        await redis.incr(`analytics:event:${event.id}:submitted`);
        await redis.del(`draft:form:${form.id}:visitor:${dbVisitor.id}`);
    } catch(err) {
        logger.warn("Redis analytics failed", err);
    }
    // - Return SubmissionResponseDTO

    return {
        submissionId: submission.id,
        status: submission.status,
        submittedAt: submission.submittedAt,
    }
  };

 /**
 * Admin: GET /api/admin/submissions/:id
 */
    async getSubmissionById( id: string ): Promise<AdminSubmissionResponseDTO> {
        const submission = await this.submissionRepo.findSubmissionById(id);
        if (!submission) {
            throw new NotFoundError("Submission not found");
        }

        const response: AdminSubmissionResponseDTO = {
            id: submission.id,
            eventId: submission.eventId,
            formId: submission.formId,
            status: submission.status,
            submittedAt: submission.submittedAt,
            answers: submission.answers.map((a) => ({
                fieldId: a.fieldId,
                fieldKey: a.fieldKey,
                ...(a.valueText !== null && { valueText: a.valueText }),
                ...(a.valueNumber !== null && { valueNumber: a.valueNumber }),
                ...(a.valueBoolean !== null && { valueBoolean: a.valueBoolean }),
                ...(a.valueDate !== null && { valueDate: a.valueDate }),
                ...(a.valueJson !== null && { valueJson: a.valueJson }),
                ...(a.fileUrl !== null && { fileUrl: a.fileUrl }),
            })),
        };

        if (submission.contact) {
            response.contact = {
                id: submission.contact.id,
                ...(submission.contact.name !== null && { name: submission.contact.name }),
                ...(submission.contact.email !== null && { email: submission.contact.email }),
                ...(submission.contact.phone !== null && { phone: submission.contact.phone }),
            };
        }

        return response;
    }


  /**
 * Admin: GET /api/admin/events/:eventId/submissions
 */
    async getSubmissionsByEvent( 
        eventId: string, 
        filters: {
            status: 'ALL' | 'VISITED' | 'STARTED' | 'SUBMITTED',
            limit: number,
            offset: number,
            fromDate?: Date,
            toDate?: Date
        }): Promise<AdminSubmissionListResponseDTO> {
        const submissions = await this.submissionRepo.findSubmissionsByEvent(
            eventId,
            {
                ...(filters.status !== "ALL" && { status: filters.status }),
                limit: filters.limit,
                offset: filters.offset,
                ...(filters.fromDate && { formDate: new Date(filters.fromDate) }),
                ...(filters.toDate && { toDate: new Date(filters.toDate) }),
            }
        );

        const items: AdminSubmissionResponseDTO[] = submissions.map((s) => {
            const dto: AdminSubmissionResponseDTO = {
                id: s.id,
                eventId: s.eventId,
                formId: s.formId,
                status: s.status,
                submittedAt: s.submittedAt,
                answers: s.answers.map((a) => ({
                fieldId: a.fieldId,
                fieldKey: a.fieldKey,
                ...(a.valueText !== null && { valueText: a.valueText }),
                ...(a.valueNumber !== null && { valueNumber: a.valueNumber }),
                ...(a.valueBoolean !== null && { valueBoolean: a.valueBoolean }),
                ...(a.valueDate !== null && { valueDate: a.valueDate }),
                ...(a.valueJson !== null && { valueJson: a.valueJson }),
                ...(a.fileUrl !== null && { fileUrl: a.fileUrl }),
                })),
            };

            if (s.contact) {
                dto.contact = {
                    id: s.contact.id,
                    ...(s.contact.name && { name: s.contact.name }),
                    ...(s.contact.email && { email: s.contact.email }),
                    ...(s.contact.phone && { phone: s.contact.phone }),
                };
            }

            return dto;
        });

        return { total: items.length, items };

  
    }   
    
    async saveDraft(slug: string, visitorUuid: string, draft: any ): Promise<void> {
        const event = await this.eventRepo.findBySlug(slug);
        if(!event) throw new NotFoundError("Event not found");

        const form = await this.formRepo.findByEventId(event.id);
        if(!form || !form.publishedAt) {
            throw new NotFoundError("Form not available");
        }

        const visitor = await this.submissionRepo.upsertVisitor({ uuid: visitorUuid });

        const key = `draft:form:${form.id}:visitor:${visitor.id}`;
        try {
            await redis.set(key, JSON.stringify(draft), "EX", 60 * 60 * 24 ); // 24hr
        } catch(err) {
            logger.warn("Redis save draft failed", err);
        }
    }

    async getDraft(slug: string, visitorUuid: string ): Promise<any | null> {
        const event = await this.eventRepo.findBySlug(slug);
        if(!event) throw new NotFoundError("Form not available");

        const form = await this.formRepo.findByEventId(event.id);
        if(!form || !form.publishedAt) {
            throw new NotFoundError("Form not available");
        }

        const visitor = await this.submissionRepo.upsertVisitor({ uuid: visitorUuid });

        const key = `draft:form:${form.id}:visitor:${visitor.id}`;
        const cached = await redis.get(key);

        return cached ? JSON.parse(cached): null;

    }

}
